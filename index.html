<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulatore di Pendoli</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e; /* Dark background */
            color: #e0e0e0; /* Light text */
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1, h2, h3 {
            color: #00bcd4; /* Cyan-like color for titles */
            text-align: center;
        }
        .container {
            background-color: #2d2d2d;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            padding: 25px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 1200px;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }
        .button-group button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .button-group button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .button-group button.active {
            background-color: #00bcd4;
            box-shadow: 0 0 10px rgba(0, 188, 212, 0.5);
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #3a3a3a;
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }
        .slider-group label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #a0a0a0;
        }
        .slider-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #555;
            outline: none;
            border-radius: 5px;
            transition: opacity .2s;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00bcd4;
            cursor: pointer;
            border: 2px solid #e0e0e0;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00bcd4;
            cursor: pointer;
            border: 2px solid #e0e0e0;
        }
        .slider-value {
            margin-left: 10px;
            font-weight: normal;
            color: #e0e0e0;
        }
        .simulate-button {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            align-self: center;
        }
        .simulate-button:hover {
            background-color: #218838;
            transform: translateY(-2px);
        }
        .output-section {
            margin-top: 30px;
            padding: 20px;
            background-color: #2d2d2d;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            min-height: 300px; /* Ensure space for animation */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .output-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
        }
        #animation-container {
            width: 100%;
            height: auto; /* Adjust height based on content */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide potential scrollbars from matplotlib output */
        }
        #animation-container iframe {
            width: 100%;
            height: 600px; /* Fixed height for the animation iframe */
            border: none;
            background-color: #1e1e1e; /* Match body background */
        }
        #text-output {
            white-space: pre-wrap; /* Preserve newlines and spaces */
            background-color: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            width: calc(100% - 30px);
            box-sizing: border-box;
            font-family: 'Consolas', 'Courier New', monospace;
            color: #00ff00; /* Green for console output */
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 2em;
            z-index: 10;
            border-radius: 8px;
            display: none; /* Hidden by default */
        }
        .loading-overlay.active {
            display: flex;
        }
        .error-message {
            color: #ff4d4d;
            font-weight: bold;
            margin-top: 15px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Simulatore Interattivo di Pendoli</h1>

    <div class="container">
        <h2>Seleziona il tipo di pendolo da simulare:</h2>
        <div class="button-group">
            <button id="btn-simple" data-pendulum-type="simple">Pendolo Semplice</button>
            <button id="btn-compound" data-pendulum-type="compound">Pendolo Composto</button>
            <button id="btn-conical" data-pendulum-type="conical">Pendolo Conico</button>
            <button id="btn-double" data-pendulum-type="double">Doppio Pendolo</button>
        </div>

        <div id="pendulum-description" style="margin-top: 20px; text-align: center; color: #a0a0a0;">
            Seleziona un tipo di pendolo per visualizzarne la descrizione e i controlli.
        </div>

        <div id="controls-container" class="controls" style="display: none;">
            <h3>Parametri di Simulazione</h3>
            <div id="sliders-area">
                <!-- Sliders will be dynamically inserted here -->
            </div>
            <button id="simulate-btn" class="simulate-button">Avvia Simulazione</button>
        </div>
    </div>

    <div class="container output-section">
        <h3>Risultati della Simulazione</h3>
        <div class="loading-overlay" id="loading-overlay">
            Caricamento simulazione...
        </div>
        <div id="animation-container">
            <!-- Animation will be injected here -->
        </div>
        <div id="text-output">
            <!-- Text output (periods, etc.) will be injected here -->
        </div>
        <div id="error-message" class="error-message" style="display: none;"></div>
    </div>

    <script>
        const pendulumTypes = {
            simple: {
                description: `
                    --- Pendolo Semplice Ideale ---
                    Il periodo è indipendente dalla massa e dall'ampiezza per piccoli angoli.
                    Per grandi angoli, il periodo aumenta e il moto non è più armonico semplice.
                    Aggiungendo smorzamento, l'ampiezza diminuisce nel tempo.
                `,
                params: [
                    { id: 'L', label: 'Lunghezza L (m)', type: 'range', min: 0.1, max: 5.0, step: 0.1, value: 1.0 },
                    { id: 'theta_0_deg', label: 'Angolo Iniziale (deg)', type: 'range', min: 5, max: 170, step: 5, value: 30 },
                    { id: 'g', label: 'Gravità g (m/s²)', type: 'range', min: 1.0, max: 20.0, step: 0.1, value: 9.81 },
                    { id: 'damping_coeff', label: 'Smorzamento γ', type: 'range', min: 0.0, max: 0.5, step: 0.01, value: 0.0 }
                ],
                endpoint: '/simulate_simple'
            },
            compound: {
                description: `
                    --- Pendolo Composto (Fisico) ---
                    Un corpo rigido che oscilla attorno a un perno non passante per il suo centro di massa.
                    Il periodo dipende dal momento d'inerzia (I), massa (M) e distanza del CM dal perno (d).
                    Esempio: per una barra sottile di lunghezza L_bar e massa M, pivotata a un'estremità, I = (1/3) * M * L_bar^2 e d = L_bar / 2.
                `,
                params: [
                    { id: 'M', label: 'Massa M (kg)', type: 'range', min: 0.1, max: 10.0, step: 0.1, value: 1.0 },
                    { id: 'd', label: 'Distanza CM (m)', type: 'range', min: 0.1, max: 2.0, step: 0.05, value: 0.5 },
                    { id: 'I', label: 'Momento Inerzia I (kgm²)', type: 'range', min: 0.01, max: 5.0, step: 0.01, value: 0.1 },
                    { id: 'theta_0_deg', label: 'Angolo Iniziale (deg)', type: 'range', min: 5, max: 90, step: 5, value: 30 },
                    { id: 'g', label: 'Gravità g (m/s²)', type: 'range', min: 1.0, max: 20.0, step: 0.1, value: 9.81 }
                ],
                endpoint: '/simulate_compound'
            },
            conical: {
                description: `
                    --- Pendolo Conico ---
                    La massa si muove in un cerchio orizzontale, mantenendo un angolo costante con la verticale.
                    Non è un'oscillazione, ma una rotazione. Il periodo dipende dall'angolo conico.
                `,
                params: [
                    { id: 'L', label: 'Lunghezza L (m)', type: 'range', min: 0.1, max: 5.0, step: 0.1, value: 1.0 },
                    { id: 'theta_conical_deg', label: 'Angolo Conico (deg)', type: 'range', min: 5, max: 85, step: 5, value: 30 },
                    { id: 'g', label: 'Gravità g (m/s²)', type: 'range', min: 1.0, max: 20.0, step: 0.1, value: 9.81 }
                ],
                endpoint: '/simulate_conical'
            },
            double: {
                description: `
                    --- Doppio Pendolo ---
                    Un sistema non lineare e caotico. Piccole variazioni nelle condizioni iniziali portano a traiettorie drasticamente diverse.
                    Osserva come il percorso del secondo pendolo diventa imprevedibile.
                `,
                params: [
                    { id: 'L1', label: 'Lunghezza L1 (m)', type: 'range', min: 0.1, max: 2.0, step: 0.1, value: 1.0 },
                    { id: 'L2', label: 'Lunghezza L2 (m)', type: 'range', min: 0.1, max: 2.0, step: 0.1, value: 1.0 },
                    { id: 'M1', label: 'Massa M1 (kg)', type: 'range', min: 0.1, max: 5.0, step: 0.1, value: 1.0 },
                    { id: 'M2', label: 'Massa M2 (kg)', type: 'range', min: 0.1, max: 5.0, step: 0.1, value: 1.0 },
                    { id: 'theta1_0_deg', label: 'Angolo Iniziale θ1 (deg)', type: 'range', min: 0, max: 179, step: 1, value: 90 },
                    { id: 'theta2_0_deg', label: 'Angolo Iniziale θ2 (deg)', type: 'range', min: 0, max: 179, step: 1, value: 90 },
                    { id: 'g', label: 'Gravità g (m/s²)', type: 'range', min: 1.0, max: 20.0, step: 0.1, value: 9.81 }
                ],
                endpoint: '/simulate_double'
            }
        };

        let currentPendulumType = null;
        const BASE_URL = 'http://127.0.0.1:5000'; // Indirizzo del server Flask

        const pendulumDescriptionDiv = document.getElementById('pendulum-description');
        const controlsContainer = document.getElementById('controls-container');
        const slidersArea = document.getElementById('sliders-area');
        const simulateBtn = document.getElementById('simulate-btn');
        const animationContainer = document.getElementById('animation-container');
        const textOutput = document.getElementById('text-output');
        const loadingOverlay = document.getElementById('loading-overlay');
        const errorMessageDiv = document.getElementById('error-message');
        const buttonGroup = document.querySelector('.button-group');

        function createSlider(param) {
            const sliderGroup = document.createElement('div');
            sliderGroup.className = 'slider-group';

            const label = document.createElement('label');
            label.htmlFor = param.id;
            label.innerHTML = `${param.label}: <span id="${param.id}-value" class="slider-value">${param.value}</span>`;

            const input = document.createElement('input');
            input.type = param.type;
            input.id = param.id;
            input.min = param.min;
            input.max = param.max;
            input.step = param.step;
            input.value = param.value;

            input.addEventListener('input', () => {
                document.getElementById(`${param.id}-value`).textContent = input.value;
            });

            sliderGroup.appendChild(label);
            sliderGroup.appendChild(input);
            return sliderGroup;
        }

        function loadPendulumControls(type) {
            currentPendulumType = type;
            const pendulum = pendulumTypes[type];

            // Update active button
            document.querySelectorAll('.button-group button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`btn-${type}`).classList.add('active');

            pendulumDescriptionDiv.innerHTML = `<pre>${pendulum.description}</pre>`;
            slidersArea.innerHTML = '';
            pendulum.params.forEach(param => {
                slidersArea.appendChild(createSlider(param));
            });
            controlsContainer.style.display = 'flex';
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';
            animationContainer.innerHTML = '';
            textOutput.textContent = '';
        }

        async function simulatePendulum() {
            if (!currentPendulumType) {
                errorMessageDiv.textContent = 'Seleziona un tipo di pendolo prima di simulare.';
                errorMessageDiv.style.display = 'block';
                return;
            }

            loadingOverlay.classList.add('active');
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';
            animationContainer.innerHTML = '';
            textOutput.textContent = '';

            const pendulum = pendulumTypes[currentPendulumType];
            const params = {};
            pendulum.params.forEach(param => {
                const input = document.getElementById(param.id);
                // Convert to number based on step type (float or int)
                params[param.id] = param.step.toString().includes('.') ? parseFloat(input.value) : parseInt(input.value);
            });

            try {
                const response = await fetch(`${BASE_URL}${pendulum.endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.animation_html) {
                    // Create an iframe to isolate the animation's JS and CSS
                    const iframe = document.createElement('iframe');
                    iframe.srcdoc = data.animation_html;
                    animationContainer.innerHTML = ''; // Clear previous animation
                    animationContainer.appendChild(iframe);
                } else {
                    animationContainer.innerHTML = '<p style="text-align: center; color: #a0a0a0;">Nessuna animazione generata.</p>';
                }

                textOutput.textContent = data.text_output || 'Nessun output testuale.';

            } catch (error) {
                console.error('Errore durante la simulazione:', error);
                errorMessageDiv.textContent = `Errore durante la simulazione: ${error.message}`;
                errorMessageDiv.style.display = 'block';
                animationContainer.innerHTML = '';
                textOutput.textContent = '';
            } finally {
                loadingOverlay.classList.remove('active');
            }
        }

        // Event Listeners
        buttonGroup.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const type = event.target.dataset.pendulumType;
                if (type) {
                    loadPendulumControls(type);
                }
            }
        });

        simulateBtn.addEventListener('click', simulatePendulum);

        // Initial load (optional, could select a default pendulum)
        // loadPendulumControls('simple'); 
    </script>
</body>
</html>
# app.py (Flask Backend)
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from scipy.integrate import odeint
import io
import sys
import json
from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app) # Abilita CORS per permettere richieste dal frontend HTML

# Imposta uno stile di sfondo scuro per una migliore visualizzazione
plt.style.use('dark_background')

# --- 1. Pendolo Semplice Ideale (Piccoli e Grandi Angoli, con Smorzamento) ---
def simulate_simple_pendulum_backend(L=1.0, theta_0_deg=30, g=9.81, damping_coeff=0.0):
    """
    Simula un pendolo semplice, mostrando il comportamento per piccoli e grandi angoli,
    e l'effetto dello smorzamento.
    Returns: animation_html (str), text_output (str)
    """
    theta_0 = np.deg2rad(theta_0_deg)
    
    # Equazioni del moto per un pendolo semplice (con smorzamento opzionale)
    # y = [theta, omega] dove omega = d(theta)/dt
    def pendulum_ode(y, t, L, g, damping_coeff):
        theta, omega = y
        dydt = [omega, -(g/L) * np.sin(theta) - damping_coeff * omega]
        return dydt

    # Array temporale per la simulazione
    t = np.linspace(0, 10, 500) # Simula per 10 secondi
    
    # Risolvi l'ODE per grandi angoli (non lineare)
    sol_large_angle = odeint(pendulum_ode, [theta_0, 0], t, args=(L, g, damping_coeff))
    theta_large_angle = sol_large_angle[:, 0]

    # Risolvi l'ODE per piccoli angoli (approssimazione lineare)
    # Per piccoli angoli, sin(theta) ~ theta, quindi l'equazione è d^2(theta)/dt^2 + (g/L)*theta = 0
    # La soluzione è theta(t) = theta_0 * cos(sqrt(g/L) * t)
    omega_small_angle = np.sqrt(g/L)
    theta_small_angle = theta_0 * np.cos(omega_small_angle * t)

    # Calcola i periodi
    period_small_angle = 2 * np.pi / omega_small_angle
    
    # Per grandi angoli, il periodo non è costante. Lo stimiamo numericamente.
    # Troviamo i picchi (massimo angolo positivo) per stimare il periodo.
    peaks_indices = np.where((np.diff(np.sign(np.diff(theta_large_angle))) < 0) & (theta_large_angle[1:-1] > 0))[0] + 1
    period_large_angle_str = "N/A (non sufficienti oscillazioni)"
    if len(peaks_indices) >= 2:
        period_large_angle = t[peaks_indices[1]] - t[peaks_indices[0]]
        period_large_angle_str = f"{period_large_angle:.4f} s"

    # --- Setup Animazione ---
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
    fig.suptitle(f'Pendolo Semplice (L={L:.2f}m, $\\theta_0$={theta_0_deg:.0f}$^\circ$, g={g:.2f}m/s$^2$, $\\gamma$={damping_coeff:.2f})')

    # Animazione del pendolo
    ax1.set_xlim(-L * 1.2, L * 1.2)
    ax1.set_ylim(-L * 1.2, L * 1.2)
    ax1.set_aspect('equal', adjustable='box')
    ax1.set_title('Animazione Pendolo')
    ax1.grid(True)

    line, = ax1.plot([], [], 'o-', lw=2, color='cyan') # Asta e massa del pendolo
    time_text = ax1.text(0.05, 0.9, '', transform=ax1.transAxes, color='white')

    # Grafico Angolo vs Tempo
    ax2.plot(t, theta_large_angle, label='Grande Angolo (Non-lineare)', color='orange')
    ax2.plot(t, theta_small_angle, '--', label='Piccolo Angolo (Lineare)', color='lime')
    ax2.set_xlabel('Tempo (s)')
    ax2.set_ylabel('Angolo (rad)')
    ax2.set_title('Angolo vs Tempo')
    ax2.legend()
    ax2.grid(True)
    
    # Marcatore del tempo corrente sul grafico dell'angolo
    time_marker, = ax2.plot([], [], 'o', color='red')

    def init():
        line.set_data([], [])
        time_text.set_text('')
        time_marker.set_data([], [])
        return line, time_text, time_marker

    def animate(i):
        x = L * np.sin(theta_large_angle[i])
        y = -L * np.cos(theta_large_angle[i])
        line.set_data([0, x], [0, y])
        time_text.set_text(f'Tempo: {t[i]:.2f} s')
        time_marker.set_data(t[i], theta_large_angle[i])
        return line, time_text, time_marker

    ani = animation.FuncAnimation(fig, animate, frames=len(t), interval=20, blit=True, init_func=init)
    
    # Capture print statements
    old_stdout = sys.stdout
    redirected_output = io.StringIO()
    sys.stdout = redirected_output
    
    print(f"Periodo (Piccoli Angoli): {period_small_angle:.4f} s")
    print(f"Periodo (Grandi Angoli, stimato): {period_large_angle_str}")
    if damping_coeff > 0:
        print(f"Coefficiente di smorzamento: {damping_coeff:.2f}")
    
    animation_html = ani.to_jshtml()
    plt.close(fig) # Chiudi il plot per evitare memory leaks

    sys.stdout = old_stdout # Restore stdout
    text_output = redirected_output.getvalue()
    
    return animation_html, text_output

# --- 2. Pendolo Composto (Fisico) ---
def simulate_compound_pendulum_backend(M=1.0, d=0.5, I=0.1, theta_0_deg=30, g=9.81):
    """
    Simula un pendolo composto (o fisico), un corpo rigido che oscilla attorno a un perno.
    Returns: animation_html (str), text_output (str)
    """
    theta_0 = np.deg2rad(theta_0_deg)

    # Equazione del moto per un pendolo composto
    # y = [theta, omega]
    def compound_pendulum_ode(y, t, M, g, d, I):
        theta, omega = y
        dydt = [omega, -(M * g * d / I) * np.sin(theta)]
        return dydt

    # Array temporale
    t = np.linspace(0, 10, 500) # Simula per 10 secondi
    
    # Risolvi l'ODE
    sol = odeint(compound_pendulum_ode, [theta_0, 0], t, args=(M, g, d, I))
    theta = sol[:, 0]

    # Calcola il periodo (per piccoli angoli)
    period = 2 * np.pi * np.sqrt(I / (M * g * d))
    
    # Calcola la lunghezza equivalente
    L_eq = I / (M * d)

    # --- Setup Animazione ---
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
    fig.suptitle(f'Pendolo Composto (M={M:.2f}kg, d={d:.2f}m, I={I:.2f}kgm$^2$, $\\theta_0$={theta_0_deg:.0f}$^\circ$, g={g:.2f}m/s$^2$)')

    # Animazione del pendolo
    ax1.set_xlim(-d * 2, d * 2)
    ax1.set_ylim(-d * 2, d * 2)
    ax1.set_aspect('equal', adjustable='box')
    ax1.set_title('Animazione Pendolo Composto')
    ax1.grid(True)

    # Rappresenta il pendolo composto come un rettangolo per la visualizzazione
    rect_width = d / 2
    rect_height = d * 1.5 
    
    # Punto di perno
    pivot_x, pivot_y = 0, 0
    ax1.plot(pivot_x, pivot_y, 'o', color='red', markersize=8, label='Perno')

    # Linea dal perno al Centro di Massa (CM)
    cm_line, = ax1.plot([], [], 'o-', lw=2, color='cyan', label='CM')
    
    # Patch del rettangolo che rappresenta il corpo
    body_patch = plt.Polygon([], closed=True, fc='lightblue', ec='blue', alpha=0.7)
    ax1.add_patch(body_patch)

    time_text = ax1.text(0.05, 0.9, '', transform=ax1.transAxes, color='white')

    # Grafico Angolo vs Tempo
    ax2.plot(t, theta, label='Angolo', color='orange')
    ax2.set_xlabel('Tempo (s)')
    ax2.set_ylabel('Angolo (rad)')
    ax2.set_title('Angolo vs Tempo')
    ax2.legend()
    ax2.grid(True)
    
    # Marcatore del tempo corrente sul grafico dell'angolo
    time_marker, = ax2.plot([], [], 'o', color='red')

    def init():
        cm_line.set_data([], [])
        body_patch.set_xy([])
        time_text.set_text('')
        time_marker.set_data([], [])
        return cm_line, body_patch, time_text, time_marker

    def animate(i):
        current_theta = theta[i]
        
        # Matrice di rotazione
        R = np.array([
            [np.cos(current_theta), -np.sin(current_theta)],
            [np.sin(current_theta), np.cos(current_theta)]
        ])
        
        # Posizione del CM rispetto al perno
        cm_x = d * np.sin(current_theta)
        cm_y = -d * np.cos(current_theta)
        
        # Coordinate locali degli angoli del rettangolo rispetto al suo CM
        local_rect_corners = np.array([
            [-rect_width/2, rect_height/2],
            [rect_width/2, rect_height/2],
            [rect_width/2, -rect_height/2],
            [-rect_width/2, -rect_height/2],
            [-rect_width/2, rect_height/2] # Chiudi il rettangolo
        ])
        
        # Ruota questi punti attorno al CM, quindi trasla il CM alla sua posizione globale
        rotated_local_corners = (R @ local_rect_corners.T).T
        global_rect_corners = rotated_local_corners + np.array([cm_x, cm_y])
        
        body_patch.set_xy(global_rect_corners)
        cm_line.set_data([pivot_x, cm_x], [pivot_y, cm_y])
        time_text.set_text(f'Tempo: {t[i]:.2f} s')
        time_marker.set_data(t[i], theta[i])
        return cm_line, body_patch, time_text, time_marker

    ani = animation.FuncAnimation(fig, animate, frames=len(t), interval=20, blit=True, init_func=init)
    
    old_stdout = sys.stdout
    redirected_output = io.StringIO()
    sys.stdout = redirected_output

    print(f"Periodo (Piccoli Angoli): {period:.4f} s")
    print(f"Lunghezza Equivalente: {L_eq:.4f} m")
    
    animation_html = ani.to_jshtml()
    plt.close(fig)

    sys.stdout = old_stdout
    text_output = redirected_output.getvalue()
    
    return animation_html, text_output

# --- 3. Pendolo Conico ---
def simulate_conical_pendulum_backend(L=1.0, theta_conical_deg=30, g=9.81):
    """
    Simula un pendolo conico, dove la massa si muove in un cerchio orizzontale.
    Returns: animation_html (str), text_output (str)
    """
    theta_conical = np.deg2rad(theta_conical_deg)
    
    if theta_conical == 0:
        return None, "L'angolo conico non può essere zero per un pendolo conico."

    # Periodo di un pendolo conico
    period = 2 * np.pi * np.sqrt(L * np.cos(theta_conical) / g)
    
    # Velocità angolare
    omega = 2 * np.pi / period
    
    # Array temporale
    t = np.linspace(0, period * 3, 500) # Simula per 3 periodi
    
    # Coordinate della massa
    r = L * np.sin(theta_conical)
    z = -L * np.cos(theta_conical) # Z è verticale, perno a (0,0,0)

    x = r * np.cos(omega * t)
    y = r * np.sin(omega * t)

    # --- Setup Animazione (3D) ---
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')
    fig.suptitle(f'Pendolo Conico (L={L:.2f}m, $\\theta_c$={theta_conical_deg:.0f}$^\circ$, g={g:.2f}m/s$^2$)')

    ax.set_xlim([-L, L])
    ax.set_ylim([-L, L])
    ax.set_zlim([-L, 0]) # Z va da -L a 0 (perno)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title('Animazione Pendolo Conico')
    
    # Punto di perno
    ax.plot([0], [0], [0], 'o', color='red', markersize=8, label='Perno')

    # Asta e massa del pendolo
    line, = ax.plot([], [], [], 'o-', lw=2, color='cyan')
    
    # Percorso della massa
    path, = ax.plot(x, y, z, '--', color='gray', alpha=0.5)

    time_text = ax.text2D(0.05, 0.9, '', transform=ax.transAxes, color='white')

    def init():
        line.set_data([], [])
        line.set_3d_properties([])
        time_text.set_text('')
        return line, time_text

    def animate(i):
        line.set_data([0, x[i]], [0, y[i]])
        line.set_3d_properties([0, z])
        time_text.set_text(f'Tempo: {t[i]:.2f} s')
        return line, time_text

    ani = animation.FuncAnimation(fig, animate, frames=len(t), interval=20, blit=True, init_func=init)
    
    old_stdout = sys.stdout
    redirected_output = io.StringIO()
    sys.stdout = redirected_output

    print(f"Periodo: {period:.4f} s")
    
    animation_html = ani.to_jshtml()
    plt.close(fig)

    sys.stdout = old_stdout
    text_output = redirected_output.getvalue()
    
    return animation_html, text_output

# --- 4. Doppio Pendolo (Caotico) ---
def simulate_double_pendulum_backend(L1=1.0, L2=1.0, M1=1.0, M2=1.0, theta1_0_deg=90, theta2_0_deg=90, g=9.81):
    """
    Simula un doppio pendolo, un sistema non lineare e caotico.
    Returns: animation_html (str), text_output (str)
    """
    theta1_0 = np.deg2rad(theta1_0_deg)
    theta2_0 = np.deg2rad(theta2_0_deg)

    # Equazioni del moto per un doppio pendolo
    # y = [theta1, omega1, theta2, omega2]
    def double_pendulum_ode(y, t, L1, L2, M1, M2, g):
        theta1, omega1, theta2, omega2 = y

        c = np.cos(theta1 - theta2)
        s = np.sin(theta1 - theta2)

        # Equazioni derivate dalla meccanica Lagrangiana
        # Fonte: https://www.myphysicslab.com/pendulum/double-pendulum-en.html
        
        # Denominatori
        den1 = (M1 + M2) * L1 - M2 * L1 * c * c
        den2 = (L2 / L1) * den1

        # Accelerazioni angolari
        alpha1 = (M2 * L1 * omega1**2 * s * c + M2 * g * np.sin(theta2) * c + M2 * L2 * omega2**2 * s - (M1 + M2) * g * np.sin(theta1)) / den1
        alpha2 = (-M2 * L2 * omega2**2 * s * c + (M1 + M2) * g * np.sin(theta1) * c - (M1 + M2) * L1 * omega1**2 * s - (M1 + M2) * g * np.sin(theta2)) / den2
        
        return [omega1, alpha1, omega2, alpha2]

    # Array temporale
    t = np.linspace(0, 20, 1000) # Simula per 20 secondi
    
    # Condizioni iniziali: [theta1, omega1, theta2, omega2]
    y0 = [theta1_0, 0, theta2_0, 0]
    
    # Risolvi l'ODE
    sol = odeint(double_pendulum_ode, y0, t, args=(L1, L2, M1, M2, g))
    theta1 = sol[:, 0]
    theta2 = sol[:, 2]

    # Converti gli angoli in coordinate cartesiane
    x1 = L1 * np.sin(theta1)
    y1 = -L1 * np.cos(theta1)
    x2 = x1 + L2 * np.sin(theta2)
    y2 = y1 - L2 * np.cos(theta2)

    # --- Setup Animazione ---
    fig, ax = plt.subplots(figsize=(8, 8))
    fig.suptitle(f'Doppio Pendolo (L1={L1:.1f}, L2={L2:.1f}, M1={M1:.1f}, M2={M2:.1f}, $\\theta_1$={theta1_0_deg:.0f}$^\circ$, $\\theta_2$={theta2_0_deg:.0f}$^\circ$)')

    ax.set_xlim(-(L1 + L2) * 1.1, (L1 + L2) * 1.1)
    ax.set_ylim(-(L1 + L2) * 1.1, (L1 + L2) * 1.1)
    ax.set_aspect('equal', adjustable='box')
    ax.set_title('Animazione Doppio Pendolo')
    ax.grid(True)

    # Punto di perno
    ax.plot(0, 0, 'o', color='red', markersize=8, label='Perno')

    # Aste e masse del pendolo
    line1, = ax.plot([], [], 'o-', lw=2, color='cyan', markersize=8)
    line2, = ax.plot([], [], 'o-', lw=2, color='lime', markersize=8)
    
    # Percorso della seconda massa (per mostrare la natura caotica)
    path, = ax.plot([], [], '-', color='gray', alpha=0.5, lw=0.5)

    time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes, color='white')

    def init():
        line1.set_data([], [])
        line2.set_data([], [])
        path.set_data([], [])
        time_text.set_text('')
        return line1, line2, path, time_text

    def animate(i):
        line1.set_data([0, x1[i]], [0, y1[i]])
        line2.set_data([x1[i], x2[i]], [y1[i], y2[i]])
        path.set_data(x2[:i+1], y2[:i+1]) # Disegna il percorso fino al frame corrente
        time_text.set_text(f'Tempo: {t[i]:.2f} s')
        return line1, line2, path, time_text

    ani = animation.FuncAnimation(fig, animate, frames=len(t), interval=20, blit=True, init_func=init)
    
    old_stdout = sys.stdout
    redirected_output = io.StringIO()
    sys.stdout = redirected_output

    # No specific print statements for double pendulum in original code, but can add if needed
    print("Simulazione Doppio Pendolo completata.")
    
    animation_html = ani.to_jshtml()
    plt.close(fig)

    sys.stdout = old_stdout
    text_output = redirected_output.getvalue()
    
    return animation_html, text_output

# Flask Routes
@app.route('/simulate_simple', methods=['POST'])
def simple_pendulum_route():
    data = request.get_json()
    try:
        animation_html, text_output = simulate_simple_pendulum_backend(
            L=data.get('L'),
            theta_0_deg=data.get('theta_0_deg'),
            g=data.get('g'),
            damping_coeff=data.get('damping_coeff')
        )
        return jsonify(animation_html=animation_html, text_output=text_output)
    except Exception as e:
        return jsonify(error=str(e)), 500

@app.route('/simulate_compound', methods=['POST'])
def compound_pendulum_route():
    data = request.get_json()
    try:
        animation_html, text_output = simulate_compound_pendulum_backend(
            M=data.get('M'),
            d=data.get('d'),
            I=data.get('I'),
            theta_0_deg=data.get('theta_0_deg'),
            g=data.get('g')
        )
        return jsonify(animation_html=animation_html, text_output=text_output)
    except Exception as e:
        return jsonify(error=str(e)), 500

@app.route('/simulate_conical', methods=['POST'])
def conical_pendulum_route():
    data = request.get_json()
    try:
        animation_html, text_output = simulate_conical_pendulum_backend(
            L=data.get('L'),
            theta_conical_deg=data.get('theta_conical_deg'),
            g=data.get('g')
        )
        if animation_html is None: # Handle specific error from conical pendulum
            return jsonify(error=text_output), 400
        return jsonify(animation_html=animation_html, text_output=text_output)
    except Exception as e:
        return jsonify(error=str(e)), 500

@app.route('/simulate_double', methods=['POST'])
def double_pendulum_route():
    data = request.get_json()
    try:
        animation_html, text_output = simulate_double_pendulum_backend(
            L1=data.get('L1'),
            L2=data.get('L2'),
            M1=data.get('M1'),
            M2=data.get('M2'),
            theta1_0_deg=data.get('theta1_0_deg'),
            theta2_0_deg=data.get('theta2_0_deg'),
            g=data.get('g')
        )
        return jsonify(animation_html=animation_html, text_output=text_output)
    except Exception as e:
        return jsonify(error=str(e)), 500

if __name__ == '__main__':
    app.run(debug=True)
